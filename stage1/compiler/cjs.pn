node = require "../parser/node.js"
token = require "../parser/token.js"
prelude = require "./prelude.js"

block = ast -> {
    more = ret -> i -> {
        sub = ast i
        if (sub 0 == node "oper" && sub 1 == "=") {
            next = "let " + compile (sub 2) + "=" + compile (sub 3)
            if (i + 1 == ast "length") {
                error "must not have assign as last in block"
            } else {
                more (List "append" ret next) (i + 1)
            }
        } else {
            next = (compile sub)
            if (i + 1 != ast "length") {
                more (List "append" ret next) (i + 1)
            } else {
                body = ret "join" ";"
                "await (async function(){" + body + ";return " + next + ";})()"
            }
        }
    }

    more (List "empty") 1
}

of_cons = f -> a -> {
    "await pn.cons(" + f + ",[" + a "join" "," + "])"
}

opcall = f -> a -> {
    "await pn.op2call(" + f + "," + a + ")"
}

call = ast -> {
    more = ret -> i -> {
        cur = ast i
        if (cur == undefined) {
            ret
        } elseif(cur 0 == token "keyword" && cur 1 == "of") {
            more = n -> {
                if (n < ast "length") {
                    first = compile (ast n)
                    rest = more (n + 1)
                    List "prepend" first rest
                } else {
                    List "empty"
                }
            }
            args = more (i + 1)
            of_cons ret args
        } else {
            next = opcall ret (compile cur)
            more next (i + 1)
        }
    }

    more (compile (ast 1)) 2
}

oper = ast -> {
    op = ast 1
    if (op == "->") {
        lhs = ast 2
        rhs = compile (ast 3)
        if (lhs 0 == node "call") {
            more = ret -> i -> {
                if (i < lhs "length") {
                    ret
                } else {
                    ret + "async(" + compile (lhs i) + ")=>"
                }
            }

            ret = "(" + more "" 1 + compile (ast (ast "length" - 1)) + ")"
            ret
        } else {
            "(async(" + lhs 1 + ")=>" + rhs + ")"
        }
    } else {
        lhs = compile (ast 2)
        rhs = compile (ast 3)
        if (op == "||") {
            "(" + lhs + "||" + rhs + ")"
        } elseif (op == "&&") {
            "(" + lhs + "&&" + rhs + ")"
        } elseif (op == "+") {
            "await pn.op2add("+lhs+","+rhs+")";
        } elseif (op == "-") {
            "await pn.op2sub("+lhs+","+rhs+")";
        } elseif (op == "*") {
            "await pn.op2mul("+lhs+","+rhs+")";
        } elseif (op == "/") {
            "await pn.op2div("+lhs+","+rhs+")";
        } elseif (op == "%") {
            "await pn.op2mod("+lhs+","+rhs+")";
        } elseif (op == "<") {
            "await pn.op2lt("+lhs+","+rhs+")";
        } elseif (op == ">") {
            "await pn.op2gt("+lhs+","+rhs+")";
        } elseif (op == "<=") {
            "await pn.op2lte("+lhs+","+rhs+")";
        } elseif (op == ">=") {
            "await pn.op2gte("+lhs+","+rhs+")";
        } elseif (op == "==") {
            "await pn.op2eq("+lhs+","+rhs+")";
        } elseif (op == ">=") {
            "await pn.op2neq("+lhs+","+rhs+")";
        }
    }
}

compile = ast -> {
    if (ast 0 == node "block") {
        if (ast "length" == 1) {
            "null"
        } else {
            block ast
        }
    } elseif (ast 0 == node "call") {
        if (ast 1 0 != token "keyword") {
            call ast
        } else {
            error "keyword"
        }
    } elseif (ast 0 == node "oper") {
        res = oper ast
        println res
        res
    } elseif (ast 0 == token "ident") {
        ast 1
    } elseif (ast 0 == token "number") {
        ast 1
    } elseif (ast 0 == token "string") {
        tick + ast 1 + tick
    } else {
        println ast
        error "unknwon ast"
    }
}

ast -> {
    res = prelude + "module.exports = (async function(){return(" + compile ast + ");})();"
    res
}